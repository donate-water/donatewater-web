/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * FieldSurvey API
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  DeleteUserDataDeleteParams,
  GetUserDetailsParams,
  IIASAFieldSurveyDtosCryptoAccount,
  IIASAFieldSurveyDtosPayoutRequest,
  VoloAbpApplicationDtosListResultDto1VoloAbpIdentityIdentityRoleDtoVoloAbpIdentityApplicationContractsVersion7020CultureNeutralPublicKeyTokenNull,
  VoloAbpHttpRemoteServiceErrorResponse,
  VoloAbpIdentityIdentityUserUpdateRolesDto
} from '.././schemas'
import { http } from '../../apiClient';
import type { ErrorType } from '../../apiClient';


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


export const getApiIdentityUsersIdRoles = (
    id: string,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<VoloAbpApplicationDtosListResultDto1VoloAbpIdentityIdentityRoleDtoVoloAbpIdentityApplicationContractsVersion7020CultureNeutralPublicKeyTokenNull>(
      {url: `/api/identity/users/${id}/roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetApiIdentityUsersIdRolesQueryKey = (id: string,) => {
    return [`/api/identity/users/${id}/roles`] as const;
    }

    
export const getGetApiIdentityUsersIdRolesQueryOptions = <TData = Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiIdentityUsersIdRolesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>> = ({ signal }) => getApiIdentityUsersIdRoles(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiIdentityUsersIdRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>>
export type GetApiIdentityUsersIdRolesQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetApiIdentityUsersIdRoles = <TData = Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersIdRoles>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetApiIdentityUsersIdRolesQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const putApiIdentityUsersIdRoles = (
    id: string,
    voloAbpIdentityIdentityUserUpdateRolesDto: VoloAbpIdentityIdentityUserUpdateRolesDto,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `/api/identity/users/${id}/roles`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: voloAbpIdentityIdentityUserUpdateRolesDto
    },
      options);
    }
  


export const getPutApiIdentityUsersIdRolesMutationOptions = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiIdentityUsersIdRoles>>, TError,{id: string;data: VoloAbpIdentityIdentityUserUpdateRolesDto}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof putApiIdentityUsersIdRoles>>, TError,{id: string;data: VoloAbpIdentityIdentityUserUpdateRolesDto}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiIdentityUsersIdRoles>>, {id: string;data: VoloAbpIdentityIdentityUserUpdateRolesDto}> = (props) => {
          const {id,data} = props ?? {};

          return  putApiIdentityUsersIdRoles(id,data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PutApiIdentityUsersIdRolesMutationResult = NonNullable<Awaited<ReturnType<typeof putApiIdentityUsersIdRoles>>>
    export type PutApiIdentityUsersIdRolesMutationBody = VoloAbpIdentityIdentityUserUpdateRolesDto
    export type PutApiIdentityUsersIdRolesMutationError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

    export const usePutApiIdentityUsersIdRoles = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiIdentityUsersIdRoles>>, TError,{id: string;data: VoloAbpIdentityIdentityUserUpdateRolesDto}, TContext>, request?: SecondParameter<typeof http>}
) => {

      const mutationOptions = getPutApiIdentityUsersIdRolesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const getApiIdentityUsersAssignableRoles = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<VoloAbpApplicationDtosListResultDto1VoloAbpIdentityIdentityRoleDtoVoloAbpIdentityApplicationContractsVersion7020CultureNeutralPublicKeyTokenNull>(
      {url: `/api/identity/users/assignable-roles`, method: 'GET', signal
    },
      options);
    }
  

export const getGetApiIdentityUsersAssignableRolesQueryKey = () => {
    return [`/api/identity/users/assignable-roles`] as const;
    }

    
export const getGetApiIdentityUsersAssignableRolesQueryOptions = <TData = Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiIdentityUsersAssignableRolesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>> = ({ signal }) => getApiIdentityUsersAssignableRoles(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiIdentityUsersAssignableRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>>
export type GetApiIdentityUsersAssignableRolesQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetApiIdentityUsersAssignableRoles = <TData = Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiIdentityUsersAssignableRoles>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetApiIdentityUsersAssignableRolesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUser = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<string>(
      {url: `/user`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = () => {
    return [`/user`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetUser = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUserTokensPayoutStatus = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<boolean>(
      {url: `/user/tokens/payout/status`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserTokensPayoutStatusQueryKey = () => {
    return [`/user/tokens/payout/status`] as const;
    }

    
export const getGetUserTokensPayoutStatusQueryOptions = <TData = Awaited<ReturnType<typeof getUserTokensPayoutStatus>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserTokensPayoutStatus>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserTokensPayoutStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTokensPayoutStatus>>> = ({ signal }) => getUserTokensPayoutStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserTokensPayoutStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserTokensPayoutStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getUserTokensPayoutStatus>>>
export type GetUserTokensPayoutStatusQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetUserTokensPayoutStatus = <TData = Awaited<ReturnType<typeof getUserTokensPayoutStatus>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserTokensPayoutStatus>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserTokensPayoutStatusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getUserScore = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<unknown>(
      {url: `/user/score`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserScoreQueryKey = () => {
    return [`/user/score`] as const;
    }

    
export const getGetUserScoreQueryOptions = <TData = Awaited<ReturnType<typeof getUserScore>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserScore>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserScoreQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserScore>>> = ({ signal }) => getUserScore(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserScore>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserScoreQueryResult = NonNullable<Awaited<ReturnType<typeof getUserScore>>>
export type GetUserScoreQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetUserScore = <TData = Awaited<ReturnType<typeof getUserScore>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserScore>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserScoreQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postUserPayout = (
    iIASAFieldSurveyDtosPayoutRequest: IIASAFieldSurveyDtosPayoutRequest,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<unknown>(
      {url: `/user/payout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: iIASAFieldSurveyDtosPayoutRequest
    },
      options);
    }
  


export const getPostUserPayoutMutationOptions = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserPayout>>, TError,{data: IIASAFieldSurveyDtosPayoutRequest}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof postUserPayout>>, TError,{data: IIASAFieldSurveyDtosPayoutRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUserPayout>>, {data: IIASAFieldSurveyDtosPayoutRequest}> = (props) => {
          const {data} = props ?? {};

          return  postUserPayout(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PostUserPayoutMutationResult = NonNullable<Awaited<ReturnType<typeof postUserPayout>>>
    export type PostUserPayoutMutationBody = IIASAFieldSurveyDtosPayoutRequest
    export type PostUserPayoutMutationError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

    export const usePostUserPayout = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserPayout>>, TError,{data: IIASAFieldSurveyDtosPayoutRequest}, TContext>, request?: SecondParameter<typeof http>}
) => {

      const mutationOptions = getPostUserPayoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const deleteUserDataDelete = (
    params?: DeleteUserDataDeleteParams,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `/user/data/delete`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteUserDataDeleteMutationOptions = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDataDelete>>, TError,{params?: DeleteUserDataDeleteParams}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserDataDelete>>, TError,{params?: DeleteUserDataDeleteParams}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserDataDelete>>, {params?: DeleteUserDataDeleteParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteUserDataDelete(params,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteUserDataDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserDataDelete>>>
    
    export type DeleteUserDataDeleteMutationError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

    export const useDeleteUserDataDelete = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDataDelete>>, TError,{params?: DeleteUserDataDeleteParams}, TContext>, request?: SecondParameter<typeof http>}
) => {

      const mutationOptions = getDeleteUserDataDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const getUserDetails = (
    params?: GetUserDetailsParams,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<unknown>(
      {url: `/user/details`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUserDetailsQueryKey = (params?: GetUserDetailsParams,) => {
    return [`/user/details`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUserDetailsQueryOptions = <TData = Awaited<ReturnType<typeof getUserDetails>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(params?: GetUserDetailsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserDetailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserDetails>>> = ({ signal }) => getUserDetails(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserDetails>>>
export type GetUserDetailsQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetUserDetails = <TData = Awaited<ReturnType<typeof getUserDetails>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
 params?: GetUserDetailsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDetails>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserDetailsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const postUserCryptoAddress = (
    iIASAFieldSurveyDtosCryptoAccount: IIASAFieldSurveyDtosCryptoAccount,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<unknown>(
      {url: `/user/crypto/address`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: iIASAFieldSurveyDtosCryptoAccount
    },
      options);
    }
  


export const getPostUserCryptoAddressMutationOptions = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserCryptoAddress>>, TError,{data: IIASAFieldSurveyDtosCryptoAccount}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof postUserCryptoAddress>>, TError,{data: IIASAFieldSurveyDtosCryptoAccount}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUserCryptoAddress>>, {data: IIASAFieldSurveyDtosCryptoAccount}> = (props) => {
          const {data} = props ?? {};

          return  postUserCryptoAddress(data,requestOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type PostUserCryptoAddressMutationResult = NonNullable<Awaited<ReturnType<typeof postUserCryptoAddress>>>
    export type PostUserCryptoAddressMutationBody = IIASAFieldSurveyDtosCryptoAccount
    export type PostUserCryptoAddressMutationError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

    export const usePostUserCryptoAddress = <TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUserCryptoAddress>>, TError,{data: IIASAFieldSurveyDtosCryptoAccount}, TContext>, request?: SecondParameter<typeof http>}
) => {

      const mutationOptions = getPostUserCryptoAddressMutationOptions(options);

      return useMutation(mutationOptions);
    }
    export const getUserCryptoAddress = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<IIASAFieldSurveyDtosCryptoAccount>(
      {url: `/user/crypto/address`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserCryptoAddressQueryKey = () => {
    return [`/user/crypto/address`] as const;
    }

    
export const getGetUserCryptoAddressQueryOptions = <TData = Awaited<ReturnType<typeof getUserCryptoAddress>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserCryptoAddress>>, TError, TData>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserCryptoAddressQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserCryptoAddress>>> = ({ signal }) => getUserCryptoAddress(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserCryptoAddress>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserCryptoAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getUserCryptoAddress>>>
export type GetUserCryptoAddressQueryError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>

export const useGetUserCryptoAddress = <TData = Awaited<ReturnType<typeof getUserCryptoAddress>>, TError = ErrorType<VoloAbpHttpRemoteServiceErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserCryptoAddress>>, TError, TData>, request?: SecondParameter<typeof http>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserCryptoAddressQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



